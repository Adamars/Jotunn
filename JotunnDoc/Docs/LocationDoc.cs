using System;
using System.IO;
using System.Linq;
using System.Text;
using Jotunn.Managers;
using UnityEngine;

namespace JotunnDoc.Docs
{
    class LocationDoc : Doc
    {

        public LocationDoc() : base("zones/location-list.md")
        {
            ZoneManager.OnVanillaLocationsAvailable += docLocations;
        }

        private void docLocations()
        {
            if (Generated)
            {
                return;
            }

            Jotunn.Logger.LogInfo("Documenting locations");

            AddHeader(1, "Locations");
            AddText("All of the locations currently in the game.");
            AddText("This file is automatically generated from Valheim using the JotunnDoc mod found on our GitHub.");

            var imageDirectory = Path.Combine(DocumentationDirConfig.Value, "images/locations");
            Directory.CreateDirectory(imageDirectory);

            var enableGroups = ZoneSystem.instance.m_locations
                .Where(zl => zl.m_prefab)
                .GroupBy(zl => zl.m_enable && zl.m_quantity != 0)
                .OrderByDescending(g => g.Key)
                .ToList();

            foreach (var enableGroup in enableGroups)
            {
                AddHeader(1, enableGroup.Key ? "Locations" : "Unused locations");

                var groups = enableGroup
                    .GroupBy(zl => zl.m_group)
                    .OrderByDescending(grouping => grouping.Key == "")
                    .ThenBy(grouping => grouping.Key)
                    .ToList();

                foreach (var group in groups)
                {
                    AddHeader(2, group.Key != "" ? group.Key : "No group");
                    AddTableHeader("Location", "Biome", "BiomeArea", "Quantity", "Exterior radius", "Properties", "Filters", "Interior");
                    foreach (var zoneLocation in group.OrderByDescending(zl => zl.m_prioritized).ThenBy(zl => zl.m_quantity))
                    {
                        GameObject exteriorPrefab = zoneLocation.m_prefab;
                        if (zoneLocation.m_location.m_hasInterior)
                        {
                            var locationTransform = zoneLocation.m_location.transform;
                            for (int i = 0; i < locationTransform.childCount; i++)
                            {
                                var childTransform = locationTransform.GetChild(i);
                                if (childTransform.name.ToLowerInvariant().Equals("exterior"))
                                {
                                    exteriorPrefab = childTransform.gameObject;
                                    break;
                                }
                            }
                        }

                        bool hasSprite = RequestSprite(Path.Combine(imageDirectory, $"{zoneLocation.m_prefab.name}-0.png"), exteriorPrefab, RenderManager.IsometricRotation);
                        if (hasSprite)
                        {
                            RequestSprite(Path.Combine(imageDirectory, $"{zoneLocation.m_prefab.name}-1.png"), exteriorPrefab, RenderManager.IsometricRotation * Quaternion.Euler(0, 180, 0));
                        }



                        AddTableRow(
                            GetNameBox(zoneLocation, hasSprite),
                            GetBiome(zoneLocation.m_biome),
                            GetBiomeArea(zoneLocation.m_biomeArea),
                            zoneLocation.m_quantity.ToString(),
                            zoneLocation.m_exteriorRadius.ToString(),
                            GetProperties(zoneLocation),
                            GetFilters(zoneLocation),
                            GetInterior(zoneLocation)
                        );
                    }
                }
            }
            Save();
        }

        private static string GetNameBox(ZoneSystem.ZoneLocation zoneLocation, bool hasSprite)
        {
            StringBuilder sb = new StringBuilder(zoneLocation.m_prefab.name);
            if (hasSprite)
            {
                string image0 = $"../../images/locations/{zoneLocation.m_prefab.name}-0.png"; 
                sb.Append($"<br><img src=\"{image0}\" onmouseover=\"this.src = this.src.replace('-0.png','-1.png')\" onmouseout=\"this.src = this.src.replace('-1.png','-0.png')\">");
            }
            return sb.ToString();
        }

        private static bool RequestSprite(string path, GameObject exteriorPrefab, Quaternion rotation)
        {
            return RenderManager.Instance.EnqueueRender(new RenderManager.RenderRequest(exteriorPrefab)
            {
                Rotation = rotation,
                FieldOfView = 20f,
                DistanceMultiplier = 1.1f
            }, (Sprite sprite) =>
            {
                if (sprite)
                {
                    var texture = sprite.texture;
                    var bytes = texture.EncodeToPNG();
                    File.WriteAllBytes(path, bytes);
                }

            });
        }

        private string GetFilters(ZoneSystem.ZoneLocation zoneLocation)
        {
            var inForest = zoneLocation.m_inForest && (zoneLocation.m_forestTresholdMin > 0 || zoneLocation.m_forestTresholdMax < 1);
            return "<ul>" +
                $"<li>Altitude: {RangeString(zoneLocation.m_minAltitude, zoneLocation.m_minAltitude)}</li>" +

                $"<li>Terrain Delta: {RangeString(zoneLocation.m_minTerrainDelta, zoneLocation.m_maxTerrainDelta)}</li>" +
                $"{(zoneLocation.m_minDistance != 0 ? $"<li>Min Distance: {zoneLocation.m_minDistance}" : "")}</li>" +
                $"{(inForest ? "" : $"<li>Forest Threshold: {RangeString(zoneLocation.m_forestTresholdMin, zoneLocation.m_forestTresholdMax)}")}</li>" +
                $"{(zoneLocation.m_minDistanceFromSimilar != 0 ? $"<li>MinDistanceFromSimilar: {zoneLocation.m_minDistanceFromSimilar}" : "")}</li>" +
                "</ul>";
        }

        private string GetInterior(ZoneSystem.ZoneLocation zoneLocation)
        {
            if (!zoneLocation.m_location.m_hasInterior)
            {
                return "";
            }
            return $"<ul>" +
                $"<li>Name: {zoneLocation.m_location.m_interiorPrefab.name}</li>" +
                $"<li>Radius: {zoneLocation.m_interiorRadius}</li>" +
                $"<li>Environment: {zoneLocation.m_location.m_interiorEnvironment}</li>" +
                $"</ul>";
        }

        private string GetProperties(ZoneSystem.ZoneLocation zoneLocation)
        {
            return $"<ul>" +
                $"{(zoneLocation.m_prioritized ? "<li>Prioritized</li>" : "")}" +
                $"{(zoneLocation.m_unique ? "<li>Unique</li>" : "")}" +
                $"{(zoneLocation.m_snapToWater ? "<li>Snap to water</li>" : "")}" +
                $"{(zoneLocation.m_centerFirst ? "<li>Place in center first</li>" : "")}" +
                GetSpawns(zoneLocation) +
                $"</ul>";
        }

        private static string GetSpawns(ZoneSystem.ZoneLocation zoneLocation)
        {
            return string.Join("",
                zoneLocation.m_prefab.GetComponentsInChildren<CreatureSpawner>()
                                    .Select(cs => cs.m_creaturePrefab.name)
                                    .Distinct()
                                    .OrderByDescending(cs => cs.ToString())
                                    .Select(creatureName => $"<li>Spawns {creatureName}</li>")
                );
        }

        private string GetBiomeArea(Heightmap.BiomeArea biomeArea)
        {
            StringBuilder biomeAreas = new StringBuilder("<ul>");
            foreach (Heightmap.BiomeArea area in Enum.GetValues(typeof(Heightmap.BiomeArea)))
            {
                if (area == Heightmap.BiomeArea.Everything || (biomeArea & area) == 0)
                {
                    continue;
                }
                biomeAreas.Append($"<li>{area}</li>");
            }

            biomeAreas.Append("</ul>");

            return biomeAreas.ToString();
        }

        private string GetBiome(Heightmap.Biome biome)
        {
            StringBuilder biomeAreas = new StringBuilder("<ul>");

            foreach (Heightmap.Biome area in Enum.GetValues(typeof(Heightmap.Biome)))
            {
                if (area == Heightmap.Biome.BiomesMax || (biome & area) == 0)
                {
                    continue;
                }

                biomeAreas.Append($"<li>{area}</li>");
            }

            biomeAreas.Append("</ul>");

            return biomeAreas.ToString();
        }
    }
}
